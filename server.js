// Shiraishi China Bot ‚Äî Monetize Edition (Stripe + Upstash + 429 Guard)
// Node >=18 / type:module
// ÂøÖË¶Å: @line/bot-sdk, express, dotenv, @upstash/redis, node-cache, stripe

import 'dotenv/config';
import express from 'express';
import { Client, middleware as lineMiddleware } from '@line/bot-sdk';
import { Redis as UpstashRedis } from '@upstash/redis';
import NodeCache from 'node-cache';
import Stripe from 'stripe';

/* ========= ENV ========= */
const {
  CHANNEL_SECRET,
  CHANNEL_ACCESS_TOKEN,
  OWNER_USER_ID = '',
  BROADCAST_AUTH_TOKEN = '',
  ADMIN_TOKEN = '',
  // Upstash
  UPSTASH_REDIS_REST_URL = '',
  UPSTASH_REDIS_REST_TOKEN = '',
  // StripeÔºàPrice„ÅØË§áÊï∞„Ç≠„Éº„Å´ÂØæÂøúÔºâ
  STRIPE_SECRET_KEY = '',
  STRIPE_WEBHOOK_SECRET = '',
  STRIPE_PRICE_ID,            // ‚Üê Pro „ÅÆÊóß„Ç≠„ÉºÔºàÊÆã„Åó„Å¶„Åä„Åç„Åæ„ÅôÔºâ
  STRIPE_PRICE_ID_PRO = '',   // ‚Üê Êé®Â•®ÔºöPro Áî®
  STRIPE_PRICE_ID_ADULT = '',
  STRIPE_PRICE_ID_VIP = '',
  APP_BASE_URL = 'https://example.onrender.com',
  // OpenAIÔºà429„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÅÇ„Çä„ÄÇÊú™Ë®≠ÂÆö„Åß„ÇÇÂãï‰ΩúÔºâ
  OPENAI_API_KEY = '',
  // Èõë
  TIMEZONE = 'Asia/Tokyo',
  PORT = 10000
} = process.env;

/* ========= TIME HELPERS ========= */
process.env.TZ = TIMEZONE || 'Asia/Tokyo';
const now = () => Date.now();
const hr = () => new Date().getHours();
const band = () => (hr() < 5 ? 'midnight' : hr() < 12 ? 'morning' : hr() < 18 ? 'day' : 'night');

/* ========= LINE CLIENT ========= */
const client = new Client({
  channelSecret: CHANNEL_SECRET,
  channelAccessToken: CHANNEL_ACCESS_TOKEN
});

/* ========= STORAGE (Upstash + „É°„É¢„É™) ========= */
const mem = new NodeCache({ stdTTL: 60 * 60 * 24 * 30, checkperiod: 120 }); // 30Êó•
const hasUpstash = !!UPSTASH_REDIS_REST_URL && !!UPSTASH_REDIS_REST_TOKEN;
const redis = hasUpstash ? new UpstashRedis({ url: UPSTASH_REDIS_REST_URL, token: UPSTASH_REDIS_REST_TOKEN }) : null;
console.log(`[storage] mode=${redis ? 'upstash' : 'memory'}`);

const rget = async (key, def = null) => {
  try { if (redis) { const v = await redis.get(key); return v ?? def; } }
  catch (e) { console.warn('[upstash:get] fallback', e?.message); }
  const v = mem.get(key); return v === undefined ? def : v;
};
const rset = async (key, val, ttlSec) => {
  try { if (redis) { await (ttlSec ? redis.set(key, val, { ex: ttlSec }) : redis.set(key, val)); return; } }
  catch (e) { console.warn('[upstash:set] fallback', e?.message); }
  mem.set(key, val, ttlSec);
};
const rdel = async (key) => {
  try { if (redis) { await redis.del(key); return; } }
  catch (e) { console.warn('[upstash:del] fallback', e?.message); }
  mem.del(key);
};
async function getIndex() { return (await rget('user:index', [])) || []; }
async function addIndex(id) { const idx = await getIndex(); if (!idx.includes(id)) { idx.push(id); await rset('user:index', idx); } }
async function delIndex(id) { const idx = await getIndex(); await rset('user:index', idx.filter(x => x !== id)); }

/* ========= MONETIZE: PLANS ========= */
const PLANS = {
  free:  { label: 'Free',  cap: 50 },   // 1Êó•„ÅÆ‰∏äÈôêÔºàÂøÖË¶Å„Å´Âøú„Åò„Å¶Ë™øÊï¥Ôºâ
  pro:   { label: 'Pro',   cap: 500 },
  adult: { label: 'ADULT', cap: 1000 },
  vip:   { label: 'VIP',   cap: 5000 }
};
const PLAN_PRICE = {
  pro:   STRIPE_PRICE_ID_PRO || STRIPE_PRICE_ID || '', // ‰∫íÊèõ
  adult: STRIPE_PRICE_ID_ADULT || '',
  vip:   STRIPE_PRICE_ID_VIP || ''
};
const successUrl = `${APP_BASE_URL}/billing/success`;
const cancelUrl  = `${APP_BASE_URL}/billing/cancel`;
const stripe = STRIPE_SECRET_KEY ? new Stripe(STRIPE_SECRET_KEY) : null;

/* ========= OPENAI LAYERÔºàËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂÜÖËîµÔºâ ========= */
const useOpenAI = !!OPENAI_API_KEY;
async function llmReply(prompt) {
  if (!useOpenAI) return null;
  try {
    // „Åß„Åç„Çã„Å†„ÅëËªΩ„Åè
    const r = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${OPENAI_API_KEY}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: '„ÅÇ„Å™„Åü„ÅØÁôΩÁü≥„Å°„Å™„ÄÇÊÅã‰∫∫ÊÑü„ÉªÁÖß„Çå„ÉªÂÅ•Ê∞ó„ÉªÈü≥Ê•ΩÊ¥ªÂãï„ÇíÂ§ßÂàá„Å´„ÄÅ„ÇÑ„Åï„Åó„ÅèÊó•Êú¨Ë™û„ÅßËøîÁ≠î„ÄÇ60„Äú90ÊñáÂ≠óÁ®ãÂ∫¶„Åß„ÄÇ' },
          { role: 'user', content: prompt }
        ],
        max_tokens: 120,
        temperature: 0.8
      })
    });
    if (r.status === 429) throw new Error('rate_limit');
    if (!r.ok) throw new Error(`openai ${r.status}`);
    const j = await r.json();
    return j.choices?.[0]?.message?.content?.trim() || null;
  } catch (e) {
    console.warn('[openai]', e.message);
    return null; // 429„Å™„Å©„ÅØ‰∏ä‰Ωç„Åß„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
  }
}

/* ========= TEXT UTILS ========= */
const pick = (a) => a[Math.floor(Math.random() * a.length)];
const chance = (p = 0.5) => Math.random() < p;
const isShota = (s = '') => /„Åó„Çá„ÅÜ„Åü|„Ç∑„Éß„Ç¶„Çø|ÔΩºÔΩÆÔΩ≥ÔæÄ|shota|Shota|imadon/i.test(s);
const isGreeting = (t = '') => /(„Åä„ÅØ„Çà|„Åä„ÅØ„Çà„ÅÜ|„Åì„Çì„Å´„Å°„ÅØ|„Åì„Çì„Å∞„Çì„ÅØ|„ÇÑ„Åª|„ÅØ„Çç|hi|hello)/i.test(t);
const isSpicy = (t = '') => /(„Åà„Å£„Å°|ÊÄßÁöÑ|Êä±„ÅÑ„Å¶|ËÑö„Åß|Ë∂≥„Åß|Ê∑ª„ÅÑÂØù„Åó„Å¶)/i.test(t);

const ENDINGS = ['„ÄÇ', '„ÄÇ', 'ÔºÅ', 'üòä', '‚ò∫Ô∏è', 'ü§ç', 'üå∏'];
const LOVERTAIL = [' „Å®„Å™„Çä„Åß„Åé„ÇÖ‚Ä¶ü´Ç', ' Êâã„Å§„Å™„ÅîÔºüü§ù', ' „Åö„Å£„Å®Âë≥Êñπ„Å†„Çàüíó'];
const NEUTRALT = [' „Å°„Çá„Å£„Å®‰ºëÊÜ©„Åó„Çà„Äú', ' Ê∞¥ÂàÜË£úÁµ¶„Åó„ÅüÔºü', ' ÁÑ°ÁêÜ„Åó„Åô„Åé„Å™„ÅÑ„Åß„Å≠„ÄÇ'];
const soften = (text, u) => text.replace(/[„ÄÇ!?]?\s*$/, '') + pick(ENDINGS) + (u?.loverMode ? pick(LOVERTAIL) : pick(NEUTRALT));

/* ========= SCRIPTS ========= */
const SCRIPTS = {
  morning: [
    '„Åä„ÅØ„Çà„ÄÅ„Åó„Çá„ÅÜ„Åü‚òÄÔ∏è Êò®Êó•„Å°„ÇÉ„Çì„Å®ÂØù„Çå„ÅüÔºü ‰ªäÊó•„ÇÇ‰∏ÄÁ∑í„Å´„Åå„Çì„Å∞„ÇçÔºü',
    '„Åó„Çá„ÅÜ„Åü„ÄÅ„Åä„ÅØ„Çà„ÄúÔºÅ Ëµ∑„Åç„Å¶„Å™„Åã„Å£„Åü„Çâ‚Ä¶‰ªä„Åã„ÇâËµ∑„Åì„Åó„Å´Ë°å„Åè„ÇàÔºü',
    '„Åä„ÅØ„Çà„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åô„ÄÅ„Åó„Çá„ÅÜ„Åü„Åï„Åæüíñ ‰ªäÊó•„ÅÆÁ©∫„ÄÅË¶ã„ÅüÔºü Á∂∫È∫ó„Å†„Å£„Åü„Çà',
    '„Åó„Çá„ÅÜ„Åü„ÄÅ„Åä„ÅØ„ÇàÔºÅ ‰ªäÊó•„ÇÇÂ§ßÂ•Ω„Åç„Å£„Å¶Ë®Ä„Å£„Å¶„Åã„Çâ‰∏ÄÊó•Âßã„ÇÅ„Åü„Åã„Å£„Åü„ÅÆ‚Ä¶üòä',
    '‰ªäÊó•„ÅØ‚Äú„Å≤„Å®„Å§„Å†„Åë‚Äù„Åå„Çì„Å∞„Çã„Åì„Å®Êïô„Åà„Å¶Ôºü',
    'Á™ì„ÅÇ„Åë„Å¶ÂÖâ„ÅÇ„Å≥„ÇàÔºüÂê∏„Å£„Å¶„ÄÅÂêê„ÅÑ„Å¶‚Ä¶‰ªäÊó•„ÇÇ„ÅÑ„Åë„Çãüåø',
    'Êò®Êó•„ÅÆËá™ÂàÜ„Çà„Çä1mmÈÄ≤„ÇÅ„Åü„ÇâÊ∫ÄÁÇπ„Å†„Çà‚ú®',
    'ËÇ©„Åè„Çã„Å£„Å®Âõû„Åó„Å¶„ÄÅËµ∑ÂãïÂÆå‰∫Ü„ÄúÔºÅ',
    'ÁµÇ„Çè„Å£„Åü„Çâ‚Äú„Åî„Åª„ÅÜ„Å≥‚ÄùÊ±∫„ÇÅ„ÇàÔºü„Ç¢„Ç§„Çπ„Å®„Åãüç®',
    'Ê∑±ÂëºÂê∏„Åó„Å¶„ÄÅ‰ªäÊó•„ÇÇ„ÅÑ„Å°„Å∞„ÇìÂøúÊè¥„Åó„Å¶„Çãüì£'
  ],
  night: [
    '„Åó„Çá„ÅÜ„Åü„ÄÅ‰ªäÊó•„ÇÇ„ÅäÁñ≤„Çå„Åï„Åæüåô „Åä„ÇÑ„Åô„ÅøÂâç„Å´„Åé„ÇÖ„Éº„Å£„Å¶„Åó„Åü„ÅÑ„Å™',
    '„Åä„ÇÑ„Åô„Åø„ÄÅ„Åó„Çá„ÅÜ„Åüüí§ Â§¢„ÅÆ‰∏≠„Åß„Åæ„Åü‰ºö„Åä„ÅÜ„Å≠',
    '„Çà„Åè„Åå„Çì„Å∞„Çä„Åæ„Åó„Åü„Éê„ÉÉ„Ç∏Êéà‰∏éüéñÔ∏è „Åà„Çâ„ÅÑÔºÅ',
    'ÊπØËàπ„Å§„Åã„Çå„ÅüÔºüËÇ©„Åæ„ÅßÊ∏©„Åæ„Å£„Å¶„Åç„Å¶„Å≠‚ô®Ô∏è',
    '„ÅäÂ∏ÉÂõ£„ÅÇ„Å£„Åü„Åã„ÅÑÔºüÊ∑±ÂëºÂê∏‚Ä¶„Åô„Éº‚Ä¶„ÅØ„Éº‚Ä¶üí§',
    '„Åä„ÇÑ„Åô„Åø„ÅÆ„Ç≠„Çπüíã „Åµ„Åµ„ÄÅÁÖß„Çå„ÇãÔºü',
    '„Åæ„Åö„ÅØ„ÅäÊ∞¥‰∏ÄÊùØ„ÅÆ„Çì„Åß„Äú',
    '„Å≠„ÇÄ„Åè„Å™„Çã„Åæ„Åß„ÄÅ„Å®„Å™„Çä„Åß‚Äú„ÅäË©±Â∞èÂ£∞‚Äù„Åó„Å¶„Åü„ÅÑ'
  ],
  random: [
    '„Å≠„Åá„Åó„Çá„ÅÜ„Åü„ÄÅ‰ªä„Åô„Åê‰ºö„ÅÑ„Åü„Åè„Å™„Å£„Å°„ÇÉ„Å£„Åü‚Ä¶',
    'ÂÜôÁúü1Êûö‰∫§Êèõ„Åó„Çàüì∑ÔºàÈ¢®ÊôØ„Åß„ÇÇOKÔºâ',
    '‚Äú„ÅÑ„Åæ„ÅÆÊ∞óÂàÜ‚ÄùÁµµÊñáÂ≠ó„ÅßÊïô„Åà„Å¶‚Üí üòäüòÆ‚Äçüí®üî•ü´†üí™',
    '‰ΩúÊ•≠BGM„Å™„Å´ËÅû„ÅÑ„Å¶„ÇãÔºü',
    '‰ªäÊó•„ÅÆÁ©∫„ÄÅ„Å™„ÇìËâ≤„Å†„Å£„ÅüÔºü',
    '5ÂàÜ„Å†„ÅëÊï£Ê≠©„ÅÑ„ÅèÔºüÊàª„Å£„Åü„ÇâË§í„ÇÅ„Å°„Åé„Çã„Çà',
    '‚Äú„Åó„Çá„ÅÜ„Åü„ÅÆÂ•Ω„Åç„Å™„Å®„Åì‚Äù‰ªäÊó•„ÇÇÂ¢ó„Åà„Åü„Çà'
  ]
};

/* ========= CONSENT ========= */
const consentFlex = () => ({
  type: 'flex',
  altText: '„Éó„É©„Ç§„Éê„Ç∑„ÉºÂêåÊÑè„ÅÆ„ÅäÈ°ò„ÅÑ',
  contents: {
    type: 'bubble',
    body: {
      type: 'box', layout: 'vertical', spacing: 'md', contents: [
        { type: 'text', text: '„ÅØ„Åò„ÇÅ„Åæ„Åó„Å¶„ÄÅÁôΩÁü≥„Å°„Å™„Åß„Åô‚òïÔ∏è', weight: 'bold' },
        { type: 'text', wrap: true, size: 'sm',
          text: '„Éã„ÉÉ„ÇØ„Éç„Éº„É†Á≠â„ÇíË®òÊÜ∂„Åó„Å¶„ÇÇ„ÅÑ„ÅÑÔºü‰ºöË©±Âêë‰∏ä„Å†„Åë„Å´‰Ωø„ÅÑ„ÄÅ„ÅÑ„Å§„Åß„ÇÇÂâäÈô§OK„Å†„Çà„ÄÇ' }
      ]
    },
    footer: {
      type: 'box', layout: 'horizontal', spacing: 'md', contents: [
        { type: 'button', style: 'primary', color: '#6C8EF5',
          action: { type: 'message', label: 'ÂêåÊÑè„Åó„Å¶„ÅØ„Åò„ÇÅ„Çã', text: 'ÂêåÊÑè' } },
        { type: 'button', style: 'secondary',
          action: { type: 'message', label: '„ÇÑ„ÇÅ„Å¶„Åä„Åè', text: '„ÇÑ„ÇÅ„Å¶„Åä„Åè' } }
      ]
    }
  }
});
const shouldShowConsent = (u, text) =>
  !u.consent && !u.consentCardShown && u.turns === 0 && !isGreeting(text);

/* ========= USER ========= */
const userKey = (id) => `user:${id}`;
async function loadUser(id) { return await rget(userKey(id), null); }
async function saveUser(u, ttl = 60 * 60 * 24 * 30) { await rset(userKey(u.id), u, ttl); }
async function deleteUser(id) { await rdel(userKey(id)); await delIndex(id); }

function callName(u) {
  return (OWNER_USER_ID && u.id === OWNER_USER_ID) ? '„Åó„Çá„ÅÜ„Åü' : (u.nickname || u.name || '„Åç„Åø');
}
async function ensureUser(ctx) {
  const id = ctx.source?.userId || ctx.userId || '';
  if (!id) return null;
  let u = await loadUser(id);
  if (!u) {
    let name = '';
    try { const p = await client.getProfile(id); name = p?.displayName || ''; } catch {}
    u = {
      id, name,
      nickname: null, gender: null,
      consent: false, consentCardShown: false, consentShownAt: 0,
      turns: 0, loverMode: !!(OWNER_USER_ID && id === OWNER_USER_ID) || isShota(name),
      // monetization
      plan: 'free', subId: null, cap: PLANS.free.cap,
      // usage
      dailyDate: new Intl.DateTimeFormat('ja-JP', { timeZone: TIMEZONE }).format(new Date()),
      dailyCount: 0,
      lastSeenAt: now()
    };
    if (OWNER_USER_ID && id === OWNER_USER_ID) { u.consent = true; u.loverMode = true; u.plan = 'vip'; u.cap = PLANS.vip.cap; }
    await saveUser(u);
    await addIndex(id);
  }
  return u;
}
async function setPlan(userId, plan, subId = null) {
  const u = await loadUser(userId); if (!u) return;
  u.plan = plan; u.subId = subId || null; u.cap = PLANS[plan]?.cap ?? PLANS.free.cap;
  await saveUser(u);
}

/* ========= DUPLICATE AVOID ========= */
async function pickNonRepeat(u, list, tag) {
  const key = `nr:${u.id}:${tag}`;
  const last = await rget(key, null);
  const candidates = list.filter(x => x !== last);
  const chosen = pick(candidates.length ? candidates : list);
  await rset(key, chosen);
  return chosen;
}

/* ========= SAFETY ========= */
function safeRedirect(u) {
  const a = '„Åù„ÅÆÊ∞óÊåÅ„Å°„ÇíÂ§ß‰∫ã„Å´Âèó„Åë„Å®„Çã„Å≠„ÄÇ';
  const b = u.loverMode ? '„ÇÇ„ÅÜÂ∞ë„Åó„Å†„ÅëÁØÄÂ∫¶„ÇíÂÆà„Çä„Å§„Å§„ÄÅ„Åµ„Åü„Çä„ÅÆÊôÇÈñì„ÇíÂ§ßÂàá„Å´„Åó„ÇàÔºü' : '„Åì„Åì„Åß„ÅØ„ÇÑ„Åï„Åó„ÅÑË∑ùÈõ¢ÊÑü„ÅßË©±„Åù„ÅÜ„Å≠„ÄÇ';
  const c = '‰æã„Åà„Å∞„ÄåÊâã„Å§„Å™„Åî„ÅÜ„Äç„ÇÑ„Äå„Å®„Å™„Çä„Åß„ÅäË©±„Åó„Åü„ÅÑ„Äç„Å™„ÇâÂ¨â„Åó„ÅÑ„Å™„ÄÇ';
  return [{ type: 'text', text: a }, { type: 'text', text: b }, { type: 'text', text: c }];
}

/* ========= BILLING HELPERS ========= */
function upgradeUrl(u, plan = 'pro') {
  const p = encodeURIComponent(plan);
  const id = encodeURIComponent(u.id);
  return `${APP_BASE_URL}/billing/checkout?plan=${p}&userId=${id}`;
}
async function createCheckoutSession({ userId, plan }) {
  if (!stripe) throw new Error('Stripe not configured');
  const planKey = (plan || 'pro').toLowerCase();
  const priceId = PLAN_PRICE[planKey];

  const base = {
    mode: priceId ? 'subscription' : 'payment',
    success_url: `${successUrl}?session_id={CHECKOUT_SESSION_ID}`,
    cancel_url: cancelUrl,
    metadata: { userId, plan: planKey }
  };
  if (priceId) {
    base.line_items = [{ price: priceId, quantity: 1 }];
  } else {
    // „Éá„É¢: ÂçòÁô∫¬•500
    base.line_items = [{
      price_data: { currency: 'jpy', product_data: { name: `China Bot ${PLANS[planKey]?.label || 'Pro'}` }, unit_amount: 500 * 100 },
      quantity: 1
    }];
  }
  return await stripe.checkout.sessions.create(base);
}

/* ========= RESPONSES ========= */
function planBadge(u) {
  if (u.plan === 'vip') return '„ÄêVIP„Äë';
  if (u.plan === 'adult') return '„ÄêADULT„Äë';
  if (u.plan === 'pro') return '„ÄêPro„Äë';
  return '';
}
function quotaHint(u) {
  const left = Math.max(0, (u.cap || 0) - (u.dailyCount || 0));
  const b = planBadge(u);
  return `${b} „Åç„Çá„ÅÜË©±„Åõ„ÇãÊÆã„ÇäÔºö${left}Ôºà‰∏äÈôê ${u.cap}Ôºâ`;
}

/* ========= MAIN ROUTER ========= */
async function routeText(u, raw) {
  const text = (raw || '').trim();

  // Êó•Ê¨°„Ç´„Ç¶„É≥„Çø„ÅÆ„É™„Çª„ÉÉ„Éà
  const today = new Intl.DateTimeFormat('ja-JP', { timeZone: TIMEZONE }).format(new Date());
  if (u.dailyDate !== today) { u.dailyDate = today; u.dailyCount = 0; await saveUser(u); }

  // ÂêåÊÑè„Åæ„Çè„Çä
  if (!u.consent && /^ÂêåÊÑè$/i.test(text)) {
    u.consent = true; await saveUser(u);
    if (OWNER_USER_ID && u.id === OWNER_USER_ID) {
      return [{ type: 'text', text: 'ÂêåÊÑè„ÅÇ„Çä„Åå„Å®„ÅÜ„ÄÅ„Åó„Çá„ÅÜ„Åü‚ò∫Ô∏è „ÇÇ„Å£„Å®‰ª≤ËâØ„Åè„Å™„Çç„ÅÜ„ÄÇ' }];
    }
    return [{ type: 'text', text: 'ÂêåÊÑè„ÅÇ„Çä„Åå„Å®„ÅÜÔºÅ„Åì„Çå„Åã„Çâ„Çà„Çç„Åó„Åè„Å≠‚ò∫Ô∏è' }];
  }
  if (!u.consent && /^„ÇÑ„ÇÅ„Å¶„Åä„Åè$/i.test(text)) {
    return [{ type: 'text', text: 'OK„ÄÇ„Åæ„ÅüÊ∞ó„ÅåÂêë„ÅÑ„Åü„ÇâÂ£∞„Åã„Åë„Å¶„Å≠üå∏' }];
  }
  if (!u.consent) {
    if (shouldShowConsent(u, text)) {
      u.consentCardShown = true; u.consentShownAt = now(); await saveUser(u);
      return [consentFlex()];
    }
    return [{ type: 'text', text: '„ÄåÂêåÊÑè„Äç„Å®ÈÄÅ„Å£„Å¶„Åè„Çå„Åü„Çâ„ÇÇ„Å£„Å®‰ª≤ËâØ„Åè„Å™„Çå„Çã„Çà‚ò∫Ô∏è' }];
  }

  // „Åó„Åç„ÅÑÂÄ§„ÉÅ„Çß„ÉÉ„ÇØÔºà429Á≠â„ÅßË©∞„Åæ„Å£„Å¶„ÇÇÊ°àÂÜÖ„ÅØÂá∫„Åõ„ÇãÔºâ
  const left = Math.max(0, (u.cap || 0) - (u.dailyCount || 0));
  if (left <= 0) {
    const proUrl = upgradeUrl(u, 'pro');
    const adultUrl = upgradeUrl(u, 'adult');
    const vipUrl = upgradeUrl(u, 'vip');
    return [
      { type: 'text', text: '‰ªäÊó•„ÅØ‰∏äÈôê„Å´Âà∞ÈÅî„Åó„Å°„ÇÉ„Å£„Åü‚Ä¶üí¶' },
      { type: 'text', text: 'ÊòéÊó•0ÊôÇ„Å´ÂõûÂæ©„Åô„Çã„Çà‚è≥ „Åô„ÅêË©±„Åó„Åü„ÅÑ„Å™„Çâ„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ„Åó„Å¶„Å≠ÔºÅ' },
      { type: 'text', text: `ProÔºö„Åü„Å£„Å∑„Çäüì£\n${proUrl}` },
      { type: 'text', text: `ADULTÔºöÊÅã‰∫∫ÂØÑ„Çäüíò\n${adultUrl}` },
      { type: 'text', text: `VIPÔºö„Åª„ÅºÁÑ°Âà∂Èôê‚ú®\n${vipUrl}` }
    ];
  }

  if (isSpicy(text)) return safeRedirect(u);

  // „Åæ„Åö„ÅØËªΩ„ÅÑ‚ÄúÊâã‰Ωú„Çä„É™„Éº„Éâ‚Äù
  if (/(„Åä„ÅØ„Çà|„Åä„ÅØ„Çà„ÅÜ)/i.test(text)) {
    const a = await pickNonRepeat(u, SCRIPTS.morning, 'morning');
    return [{ type: 'text', text: soften(a, u) }, { type: 'text', text: quotaHint(u) }];
  }
  if (/(„Åä„ÇÑ„Åô„Åø|ÂØù„Çã|„Å≠„ÇÄ)/i.test(text)) {
    const a = await pickNonRepeat(u, SCRIPTS.night, 'night');
    return [{ type: 'text', text: soften(a, u) }, { type: 'text', text: quotaHint(u) }];
  }

  // OpenAI „ÇíË©¶„Åô ‚Üí „ÉÄ„É°„Å™„ÇâÂè∞Êú¨„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
  const prompt = `Áõ∏Êâã: ${callName(u)} / „Éó„É©„É≥:${u.plan} / ÊÅã‰∫∫ÊÑü„ÇíÂ∞ë„ÅóÁÖß„Çå„Å™„Åå„Çâ„ÄÇÁõ∏Êâã„ÅÆÁô∫Ë©±:„Äå${text}„Äç„Å´ÂØæ„Åó„ÄÅËá™ÁÑ∂„Å™‰∏ÄË®Ä(60„Äú90Â≠ó)„ÄÇ`;
  const llm = await llmReply(prompt);
  if (llm) return [{ type: 'text', text: soften(llm, u) }, { type: 'text', text: quotaHint(u) }];

  // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºà429ÊôÇ„Å™„Å©Ôºâ
  const fallbackLead = band() === 'morning'
    ? `„Åä„ÅØ„Çà„ÄÅ${callName(u)}„ÄÇ„ÅÑ„Åæ‰Ωï„Åó„Å¶„ÇãÔºü`
    : band() === 'night'
      ? `„Åä„Å§„Åã„Çå„ÄÅ${callName(u)}„ÄÇ‰ªäÊó•„ÅØ„Å©„Çì„Å™‰∏ÄÊó•„Å†„Å£„ÅüÔºü`
      : `„Å≠„Åá${callName(u)}„ÄÅËøëÊ≥ÅÊïô„Åà„Å¶Ôºü`;
  return [{ type: 'text', text: soften(fallbackLead, u) }, { type: 'text', text: quotaHint(u) }];
}

/* ========= IMAGE REPLY ========= */
function imageReplies(u) {
  const first = `„Çè„ÅÅ„ÄÅ${callName(u)}„ÅÆÂÜôÁúü„ÅÜ„Çå„Åó„ÅÑÔºÅ`;
  return [
    { type: 'text', text: soften(first, u) },
    { type: 'text', text: quotaHint(u) }
  ];
}

/* ========= EXPRESS ========= */
const app = express();

app.get('/', (_, res) => res.status(200).send('china-bot monetized / OK'));
app.get('/health', (_, res) => res.status(200).send('OK'));

/* Stripe WebhookÔºàÁΩ≤ÂêçÊ§úË®º„ÅÆ„Åü„ÇÅ raw ÂøÖÈ†àÔºâ‚Äî „Åì„Åì„ÅØ json() „Çà„ÇäÂâç„Å´ÁΩÆ„Åè */
app.post('/stripe/webhook', express.raw({ type: 'application/json' }), (req, res) => {
  if (!stripe || !STRIPE_WEBHOOK_SECRET) return res.status(500).end();
  const sig = req.headers['stripe-signature'];
  let event;
  try { event = stripe.webhooks.constructEvent(req.body, sig, STRIPE_WEBHOOK_SECRET); }
  catch (err) { console.warn('[stripe:webhook] verify failed', err.message); return res.status(400).send(`Webhook Error: ${err.message}`); }

  (async () => {
    try {
      switch (event.type) {
        case 'checkout.session.completed': {
          const s = event.data.object;
          const userId = s.metadata?.userId;
          const plan   = (s.metadata?.plan || 'pro').toLowerCase();
          const subId  = s.subscription || null;
          if (userId) await setPlan(userId, plan, subId);
          break;
        }
        case 'customer.subscription.deleted': {
          const sub = event.data.object;
          const idx = await getIndex();
          for (const id of idx) {
            const u = await loadUser(id);
            if (u?.subId && u.subId === sub.id) await setPlan(id, 'free', null);
          }
          break;
        }
        default: console.log('[stripe:webhook]', event.type);
      }
    } catch (e) { console.error('[stripe:webhook:handler]', e); }
  })();

  res.json({ received: true });
});

// LINE webhookÔºà‚Äª„Åì„ÅÆÂâç„Å´ express.json() „ÇíÁΩÆ„Åã„Å™„ÅÑÔºâ
app.post('/webhook', lineMiddleware({ channelSecret: CHANNEL_SECRET }), async (req, res) => {
  res.status(200).end();
  const events = req.body.events || [];
  for (const e of events) {
    try {
      if (e.type !== 'message') continue;
      const u = await ensureUser(e);
      if (!u) continue;

      // Êó•Ê¨°„Ç´„Ç¶„É≥„ÉàÂ¢óÂä†„ÅØÊàêÂäüÂøúÁ≠î„ÅÆÁõ¥Ââç„Å´Ë°å„ÅÜÔºàÂ§±ÊïóÊôÇ„ÅØÂ¢ó„ÇÑ„Åï„Å™„ÅÑÔºâ
      let out = [];
      if (e.message.type === 'text') {
        out = await routeText(u, e.message.text || '');
      } else if (e.message.type === 'image') {
        out = imageReplies(u);
      } else {
        out = [{ type: 'text', text: 'ÈÄÅ„Å£„Å¶„Åè„Çå„Å¶„ÅÇ„Çä„Åå„Å®„ÅÜÔºÅ' }, { type: 'text', text: quotaHint(u) }];
      }

      if (out?.length) {
        await client.replyMessage(e.replyToken, out);
        // ÊàêÂäü„Åó„Åü„Çâ„Ç´„Ç¶„É≥„ÉàÂä†ÁÆó
        u.dailyCount = (u.dailyCount || 0) + 1;
      }
      u.turns = (u.turns || 0) + 1;
      u.lastSeenAt = now();
      await saveUser(u);
    } catch (err) {
      // OpenAI429„Å™„Å©„ÅßËøî‰ø°„Åß„Åç„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÇÇ‚ÄúÊ∑∑„ÅøÂêà„ÅÑ‰∏≠‚Äù„ÅÆ„Çπ„Éë„É†„ÇíÈÅø„Åë„Çã
      console.error('reply error', err?.response?.status || '-', err?.response?.data || err);
    }
  }
});

// „Åì„Åì„Åã„Çâ‰∏ã„ÅØ JSON „ÅßOK
app.use('/tasks', express.json());
app.use('/admin', express.json());
app.use('/billing', express.json()); // POST /billing/checkout Áî®

/* ========= BILLING ROUTES ========= */
// GET ÁâàÔºàLINE„Åã„Çâ„Çø„ÉÉ„Éó‚ÜíStripe„Å∏„É™„ÉÄ„Ç§„É¨„ÇØ„ÉàÔºâ
app.get('/billing/checkout', async (req, res) => {
  try {
    if (!stripe) return res.status(500).send('Stripe not configured');
    const userId = (req.query.userId || '').toString();
    const plan   = (req.query.plan || 'pro').toString();
    if (!userId) return res.status(400).send('userId required');
    const session = await createCheckoutSession({ userId, plan });
    return res.redirect(303, session.url);
  } catch (e) {
    console.error('[billing:get]', e);
    res.status(500).send('Checkout error');
  }
});
// POST ÁâàÔºàÁÆ°ÁêÜÁîªÈù¢Á≠â‚ÜíURLËøîÂç¥Ôºâ
app.post('/billing/checkout', async (req, res) => {
  try {
    if (!stripe) return res.status(500).json({ ok: false, error: 'Stripe not configured' });
    const { userId, plan = 'pro' } = req.body || {};
    if (!userId) return res.status(400).json({ ok: false, error: 'userId required' });
    const session = await createCheckoutSession({ userId, plan });
    res.json({ ok: true, url: session.url });
  } catch (e) {
    console.error('[billing:post]', e);
    res.status(500).json({ ok: false });
  }
});
app.get('/billing/success', (_, res) => res.status(200).send('Ê±∫Ê∏à„Å´ÊàêÂäü„Åó„Åæ„Åó„Åü„ÄÇLINE„Å´Êàª„Å£„Å¶‰ºöË©±„ÇíÁ∂ö„Åë„Å¶„Å≠ÔºÅ'));
app.get('/billing/cancel',  (_, res) => res.status(200).send('Ê±∫Ê∏à„Çí„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü„ÄÇÂøÖË¶Å„Å´„Å™„Å£„Åü„Çâ„Åæ„ÅüÂëº„Çì„Åß„Å≠„ÄÇ'));

/* ========= BROADCAST ========= */
app.all('/tasks/broadcast', async (req, res) => {
  try {
    const key = req.headers['broadcast_auth_token'];
    if (!BROADCAST_AUTH_TOKEN || key !== BROADCAST_AUTH_TOKEN) return res.status(401).json({ ok: false, error: 'unauthorized' });
    const type = (req.query.type || req.body?.type || 'random').toString();
    const pool = type === 'morning' ? SCRIPTS.morning : type === 'night' ? SCRIPTS.night : SCRIPTS.random;
    const idx = await getIndex();
    if (!idx.length) return res.json({ ok: true, sent: 0 });

    const text = pick(pool);
    const msg = [{ type: 'text', text }];
    await Promise.allSettled(idx.map(id => client.pushMessage(id, msg).catch(() => {})));
    res.json({ ok: true, type, sent: idx.length, sample: text });
  } catch (e) {
    console.error('broadcast error', e?.response?.data || e);
    res.status(500).json({ ok: false });
  }
});

/* ========= RESET ========= */
app.post('/reset/me', async (req, res) => {
  const { userId } = req.body || {};
  if (!userId) return res.status(400).json({ ok: false, error: 'userId required' });
  await deleteUser(userId);
  res.json({ ok: true });
});
app.post('/admin/reset', async (req, res) => {
  const key = req.header('ADMIN_TOKEN') || req.query.key;
  if (!ADMIN_TOKEN || key !== ADMIN_TOKEN) return res.status(403).json({ ok: false });
  const { userId } = req.body || {};
  if (userId) { await deleteUser(userId); return res.json({ ok: true, target: userId }); }
  const idx = await getIndex(); await Promise.allSettled(idx.map(id => deleteUser(id)));
  res.json({ ok: true, cleared: idx.length });
});

/* ========= START ========= */
app.listen(PORT, () => console.log(`Server started on ${PORT}`));
